import { Image, Notes, Appear } from '@mdx-deck/components'
import { FullScreenCode } from 'mdx-deck/layouts'

import future from '@mdx-deck/themes/future'
import aspect from '@mdx-deck/themes/aspect'
import customTheme from './theme'

export const themes = [future, aspect, customTheme]

The Pragmatic Front-end Tester

---

I wanted to talk about testing the front-end.

<Notes>
  "Who's writing FE apps? Who's testing? Nah, you all test ur apps. You might
  not automate those tests, but I'm sure you are testing. Why do we automate?
  What are the goals?"
</Notes>

---

...but I wanted to do it following a pragmatic approach.

---

> "solving problems in a sensible way that suits the conditions that really exist now, rather than obeying fixed theories, ideas, or rules."

as opposed to idealistic.

---

# üëã

#### Adri√† Fontcuberta

Senior(?) Front-end Engineer @ Holaluz

`afontcu.dev` &nbsp;&nbsp;¬∑&nbsp;&nbsp; `@afontcu_` &nbsp;&nbsp;¬∑&nbsp;&nbsp; `npx afontcu`

<Notes>Holaluz: We sell electricity that is from 100% renewable sources</Notes>

---

**Idealistic**: "strive for a 100% code coverage possible"

<Appear>

**Pragmatic**: Opportunity cost of testing.

</Appear>

<Notes>
  Opportunity costs represent the benefits we miss out on when choosing one
  alternative over another.

While testing you are not actually developing new features. So there must be a
greater reason to write that test.

</Notes>

---

What has changed?

<Notes>
  Over the years, FE apps have increased in complexity, and a lot of
  responsibility has moved from the backend to the FE. Thus, the need for better
  testing approaches is logical. However, tools weren't there yet, and we didn't
  have the knowledge or experience.
</Notes>

---

Test as little as possible.

_(but no less)_.

---

### A warn on implementation details

<Appear>

1. Your test does something your consumer won't.

2. Your test breaks on refactor.

</Appear>

<Notes>
  Refactor: changing internal implementation without modifying external behavior
</Notes>

---

### okay, what should I test then

Changing props.

User interactions (events).

Subscription changes (store, APIs, routing...).

<Notes>
  Use user interactions instead of calling methods in the component directly.
  That also brings your tests closer to the way how your components are used
  in production. Think about your component UI as a contract for test.

If you have a component which has 50 tiny methods, don't test them one by one.

Instead of that, click on buttons/links triggering these methods.

If you are getting data from store or passing them as props, don't check if
the data has been assigned to vm, check data is displayed in the DOM instead.

</Notes>

---

(small) demo time!

---

`vue-testing-library`?

Isn't `@vue/test-utils` the official testing suite for Vue?

<Notes>

Built on top of vue test utils. Hides methods that get you closer to testing
implementation details, while providing user-focused helpers.

If you want to avoid impl details, use tools that help you out.

Helps you querying for nodes similarly to how users would find them.

</Notes>

---

`dom-testing-library`

`vue-testing-library`

`react-testing-library`

`cypress-testing-library`

[https://testing-library.com/](https://testing-library.com/)

<Notes>

Different environments, same queries and API. One less thing to learn.

</Notes>

---

**Idealistic**: Follow the evergreen testing pyramid.

<Appear>

**Pragmatic**: Focus on the outcome. Get closer to reality.

</Appear>

<Notes>

Brings your tests closer to the way how your components are used
in production.

</Notes>

---

yo, what about testing pyramid?

what about unit testing?

should I write integration tests?

dude I heard end-to-end testing is the way to go

---

(testing pyramid img)

---

(testing code img)

---

(testing trophy img)

---

I came up with my personal approach

---

**S**ensible

**H**ierarchy of

**R**esources about

**U**nified

**G**UI testing

---

# SHRUG

Testing Pyramid

---

# ü§∑‚Äç

Testing Pyramid

---

# ¬Ø\\\_(„ÉÑ)\_/¬Ø

Testing Pyramid

---

a word on mocking

<Notes>
  Moking is a powerful feature. However, every time we mock we introduce holes
  to reality, where things can go wrong. We need to use mocks sensibly.
</Notes>

---

| What         | Type&nbsp;&nbsp;&nbsp; | Service    | API  | Store      |
| ------------ | ---------------------- | ---------- | ---- | ---------- |
| Dumb comps   | &nbsp;&nbsp;&nbsp;ü§∑   | -          | -    | -          |
| Smart comps  | &nbsp;&nbsp;&nbsp;ü§∑   | don't mock | mock | don't mock |
| Store (Vuex) | &nbsp;&nbsp;&nbsp;ü§∑   | mock       | mock | -          |
| API Services | &nbsp;&nbsp;&nbsp;ü§∑   | mock       | mock | mock       |

---

The good ol' pyramid

unit -> integration -> e2e

---

A more sensitive approach

static -> unit -> int -> e2e (testing trophy)

brought to you by Kent C. Dodds.

---

Cypress !== e2e

<Notes>
  Not *exclusively*. You can use it to perform e2e tests, but it also features
  cool tools to mock calls, so use it to write high-level integration tests.
</Notes>

---

**Static &nbsp; &nbsp; Unit &nbsp; &nbsp; Integration &nbsp; &nbsp; End-to-End**

<div style={{ 
  display: 'grid', 
  gridTemplateColumns: '1fr 1fr 1fr',
  justifyContent: 'space-between',
}}>

<p style={{margin: '0', textAlign:'left'}}>Cheap</p>

&rarr;

<p style={{margin: '0', textAlign:'right'}}>Expensive</p>

<p style={{margin: '0', textAlign:'left'}}>Fast</p>

&rarr;

<p style={{margin: '0', textAlign:'right'}}>Slow</p>

<p style={{margin: '0', textAlign:'left'}}>Narrowed</p>

&rarr;

<p style={{margin: '0', textAlign:'right'}}>Global</p>

</div>

---

**Static &nbsp; &nbsp; Unit &nbsp; &nbsp; Integration &nbsp; &nbsp; End-to-End**

<div style={{ 
  display: 'grid', 
  gridTemplateColumns: 'auto 1fr auto',
  justifyContent: 'space-between',
}}>

<p style={{margin: '0', textAlign:'left'}}>Abstract</p>

&rarr;

<p style={{margin: '0', textAlign:'right'}}>Real</p>

<p style={{margin: '0', textAlign:'left'}}>Simple problems</p>

&rarr;

<p style={{margin: '0', textAlign:'right'}}>Complex ones</p>

<p style={{margin: '0', textAlign:'left'}}>Code-focused</p>

&rarr;

<p style={{margin: '0', textAlign:'right'}}>Business-focused</p>

</div>

---

Okay Adri√† enough said. How to start?

---

### 0. Configure Eslint

...and use Prettier to avoid stylistic arguments.

<Notes>
  If you use TS or Flow and their typing system, you get extra points.
</Notes>

---

### 1. Decide what's the most important part of your app

From a business point of view. Where's the value?

---

### 2. Add end-to-end\* tests to cover the happy paths\*\*

<Appear>

_\*: Or mocked e2e. Whatever._

_\*\*: API responses such as 200, 404, 401..._

</Appear>

<Notes>
  I'd use Cypress here. Writing it with Cypress is gonna help you get your head
  around the feature, which is a wonderful side effect.
</Notes>

---

### 3. Add unit tests for isolated parts

The closer to the business logic, the better.

<Notes>
  Think of those plain JS files with utilities, entities, whatever. Framework
  agnostic. UI agnostic. DOM agnostic.

What about Vuex actions?

</Notes>

---

### 4. Add integration tests to cover critical parts and edge cases.

Complex component trees, Vuex interactions...

<Notes>

These are quite useful to underline parts of your app that are too complex.

Is this component doing too much?
Is it tied to too many elements?

</Notes>

---

If it's hard to test, it's hard to **understand**.

If it's hard to understand, it's hard to **maintain**.

---

```js
```
