import { Image, Notes, Appear, Embed } from '@mdx-deck/components'  
import { FullScreenCode, Invert } from 'mdx-deck/layouts'

import future from '@mdx-deck/themes/future'
import aspect from '@mdx-deck/themes/aspect'
import highlight from '@mdx-deck/themes/syntax-highlighter-prism'
import customTheme from './theme'

export const themes = [future, aspect, highlight, customTheme]

## The Pragmatic Front-end Tester

---

I wanted to talk about testing the front-end.

<Notes>
  "Who's writing FE apps? Who's testing? Are you confiden? Would you ship
  without manually testing?"

Over the years, FE apps have increased in complexity, responsibility has moved 
from the backend to the FE. 
</Notes>

---

...and I wanted to do it following a pragmatic approach.

---

a _what_?

---

pragmatic:

> "solving problems in a sensible way that suits the conditions that really exist now, rather than obeying fixed theories, ideas, or rules."

<Appear>

as opposed to idealistic.

</Appear>

---

# üëã

## Adri√† Fontcuberta

Senior(?) Front-end Engineer @ Holaluz

`afontcu.dev` &nbsp;&nbsp;¬∑&nbsp;&nbsp; `@afontcu_` &nbsp;&nbsp;¬∑&nbsp;&nbsp; `npx afontcu`

<Notes>Holaluz: We sell electricity that is from 100% renewable sources</Notes>

---

Wait, wait. Are you gonna explain me the testing pyramid again?

---

<Invert>

<Image src="assets/pyramid-1.png" size="contain" />

</Invert>

---

<Invert>

<Image src="assets/pyramid-2.png" size="contain" />

</Invert>

---

<Invert>

<Image src="assets/pyramid-3.png" size="contain" />

</Invert>

---

<Invert>

<Image src="assets/pyramid-4.png" size="contain" />

</Invert>

---

Are we gonna discuss unit testing vs. integration testing?

---

<video controls muted src="assets/unit-vs-int.mp4" />

---

2 unit tests, 0 integration tests

<video controls muted src="assets/unit-vs-int-2.mp4" />

---

> The hardest part of testing is knowing what to test.

_- Me*, 2019_

<Appear>

_\*: and probably a thousand people before._

</Appear>

---

What are we gonna test?

---

Okay Adri√†, say no more. How to start?

<Notes>
  I'll show you how I test a component. This might be called an integration test,
  but again, I couldn't care less.
</Notes>

---

# demo time!

---

What happened here?

---

### Death by **implementation details**

<Appear>

Your test does something your consumer won't.

Your test breaks on refactor.

</Appear>


<Notes>
  Exemple canviar nom de m√®tode

  Refactor: changing internal implementation without modifying external behavior
</Notes>

---

A pragmatic front-end testers needs a **pragmatic testing toolbelt**.

---

Jest + `vue-testing-library`

<Notes>

Built on top of vue test utils. Hides methods that get you closer to testing
implementation details, while providing user-focused helpers.

If you want to avoid impl details, use tools that help you out.

Helps you querying for nodes similarly to how users would find them.

</Notes>

---

`dom-testing-library`

`vue-testing-library`

`react-testing-library`

`cypress-testing-library`


<Notes>

Different environments, same queries and API. One less thing to learn.

</Notes>

---

https://testing-library.com/

---

### In short:

> ‚ÄúThe more your tests resemble the way your software is used, the more confidence they can give you.‚Äù

[Kent C. Dodds](https://twitter.com/kentcdodds/status/977018512689455106)

---

Changing props and user interactions (_a.k.a. `inputs`_).

Events, subscriptions (_a.k.a. `outputs`_).

<Notes>
  Component UI as a contract for tests.
  
  User interactions instead of calling methods.
  
  If you are getting data from store or passing them as props, don't check if
the data has been assigned to vm, check data is displayed in the DOM instead.
</Notes>

---

# Let's try again!

---

### Is that enough?

_(spoiler: no)_

---

Can we get **closer to the user**?

Can we improve the **Developer Experience**?

---

# Enter Cypress ‚ù§Ô∏è

<Notes>
  Is an amazing tool to write end-to-end tests. It can test anything that runs
  on a browser (including Vue).

  It includes a ton of tools and features out-of-the-box: mocking/stubbing,
  assertions, DOM selectors...

  Focus on DX.
</Notes>

---

# Demo time!

---

Hey, Adri. Why would I write integration tests with Jest if I can use Cypress?

---

That's a pretty good question.

---

## Integration tests tend to be

cheaper

faster

more focused

<Notes>
  Cheaper to write and run.

However, we are kinda getting there with tools such as Cypress.
</Notes>

---

## a pragmatic approach

I'd write **e2e tests** to cover the common happy paths.

Then, I'd add a bunch of **integration tests** to fill in the gaps.

---

Show me cools things about Cypress

---

## Cool Thing number 1:

Stubbing XHR requests

<Notes>
  Erasing the actual implementation of a function, capturing calls to the
  function, allowing spying and configuration of return values effects. 

However, every time we mock we introduce holes to reality.
</Notes>

---

```js
it('Renders error message if fetched list is empty', () => {
  cy.server()
    .route('GET', /api\/v2\/pokemon/, { count: 0, results: [] })
    .as('pokemonList')

  cy.visit('/')
    .wait('@pokemonList')
    .getByText(/no results!/i)
})
```

<Notes>
Use external fixtures files

Specify the response code (404, 500)

Set a delay

Intercept the request or the response and interact with it...
</Notes>

---

https://docs.cypress.io/guides/guides/network-requests.html

---

## Cool Thing number 2:

Custom Commands

---

<FullScreenCode>

```js
// test/support/commands.js

Cypress.Commands.add('assertURL', url => {
  const baseUrl = Cypress.config().baseUrl
  cy.url().should('eq', baseUrl + url)
})


// someTest.js

it('Navigates to detailed view', () => {
  cy.visit('/').getByText('#129').click()

  cy.assertURL('/pokemon/129')
})
```

</FullScreenCode>

---

```js
Cypress.Commands.add('login', email => {
  cy.request({ url: '/users', method: 'POST', body: email })
    .its('body')
    .then(({ email, password }) => {
      cy.request({
        url: '/login',
        method: 'POST',
        body: { email, password },
      })
    })
})
```

<Notes>
  Additional benefit: building UI programmatically, not as a user would!
</Notes>

---

```js
it('can update a todo', () => {
  createTodo('Learn Cypress')
    .then(updateName('Learn custom commands composition'))
    .then(markAsDone)
    .then(saveTodo)
    .then(console.log)
})

// a few hundred milliseconds later:
// { name: "Learn Cypress custom commands composition", done: true }
```

<Notes>
  Source: https://medium.com/@NicholasBoll/cypress-io-scaling-e2e-testing-with-custom-commands-6b72b902aab
</Notes>

---

https://docs.cypress.io/api/cypress-api/custom-commands.html

---

Oh... poor little unit test.

---

## Where are unit tests useful:

Helper utilities

Vuex getters / mutations

Vuex actions\*

Entities, Value Objects...

<Notes>
  If they are either: Easily tested (simple functions) or Critical to business.

Vuex actions to help you develop: they usually contain a heavy chunk of logic.
Tests will help you reason about that logic.

</Notes>

---

General tips for the pragmatic (front-end) tester

---

# tip #1 

Use Eslint.

Seriously, it is a testing tool.

Then, turn off the stylistic rules and install Prettier.

---

# tip #2

You found a bug? Great. üëç

Now, **write a test before** fixing it and watch it fail.

Then fix it. Make sure the bug stays dead.

---

# tip #3

Having a hard time testing a piece of code? Do you need to mock half the app? That's a bad smell.

<Appear>

If it's hard to test, it's hard to **understand**.

If it's hard to understand, it's hard to **maintain**.

</Appear>

<Notes>
  Testing outline bad smells and pieces of code that could use some refactor.
</Notes>

---

wrapping up.

---

<Appear>

Write tests, but **not too many**. Focus on ROI.

Add **integration** tests higher up in tree.

Add **e2e** tests with Cypress to test happy paths.

Add fast **unit** tests for small modules and functions.

</Appear>

---

### To read more

https://github.com/afontcu/awesome-learning#testing

---

# Thank you! üëã

`afontcu.dev` &nbsp;&nbsp;¬∑&nbsp;&nbsp; `@afontcu_` &nbsp;&nbsp;¬∑&nbsp;&nbsp; `npx afontcu`
