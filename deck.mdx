import { Image, Notes, Appear, Embed } from '@mdx-deck/components'  
import { FullScreenCode, Invert } from 'mdx-deck/layouts'
import future from '@mdx-deck/themes/future'
import aspect from '@mdx-deck/themes/aspect'

import customTheme from './theme'
import Waver from './Waver'

export const themes = [future, aspect, customTheme]

## The Pragmatic Front-end Tester

---

I wanted to talk about **testing the front-end**.

<Notes>
  "Who's writing FE apps? Who's testing? Are you confiden? Would you ship
  without manually testing?"

Over the years, FE apps have increased in complexity, responsibility has moved 
from the backend to the FE. 
</Notes>

---

...and I wanted to do it following a **pragmatic** approach.

---

## Some Facts

<Appear>

I have ~30 minutes üèÉ‚Äç‚ôÇÔ∏è

<s>Why should we test?</s>

<s>Testing beyond avoiding regressions</s>

<s>Visual regression testing</s>

Focused on front-end apps

</Appear>

<Notes>
  Speed things up.

  Focus on avoiding regressions, not discovering best ways of developing a feature

  Frontend apps: Ni Node ni librerias ni otros contextos
</Notes>

---

## üëã Hi! I'm Adri√† Fontcuberta

Senior(?) Front-end Engineer @ **Holaluz**

`afontcu.dev` &nbsp;&nbsp;¬∑&nbsp;&nbsp; `@afontcu_` &nbsp;&nbsp;¬∑&nbsp;&nbsp; `npx afontcu`

<Notes>
What's the first thing that comes to your mind when talking about software testing?
</Notes>

---

The Testing Pyramid‚Ñ¢

---

<Image src="images/drake-nah.png" size="contain" />

---

Focusing on the **confidence** each test provides?

---

<Image src="images/drake-yea.jpg" size="contain" />

---

Let's see a day-to-day example...

<Notes>
  The kind of component we develop here at Holaluz daily.
</Notes>

---

a Counter component

# ü§∑‚Äç‚ôÄÔ∏è

---

```html
<template>
  <div>
    <p class="counter">You clicked {{ count }} times</p>
    <button @click="increment">increment</button>
  </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),

  methods: {
    increment() { this.count++ },
  },
}
</script>
```

---

```
import { mount } from '@vue/test-utils'
import Counter from './Counter'

test('increments value on click', () => {
  const wrapper = mount(Counter)                      
  



  
  

  
})
```

---

```
import { mount } from '@vue/test-utils'
import Counter from './Counter'

test('increments value on click', () => {
  const wrapper = mount(Counter)
  const paragraph = wrapper.find('.counter')

  expect(paragraph.text()).toBe('You clicked 0 times')

  
  

  
})
```

---

```
import { mount } from '@vue/test-utils'
import Counter from './Counter'

test('increments value on click', () => {
  const wrapper = mount(Counter)
  const paragraph = wrapper.find('.counter')

  expect(paragraph.text()).toBe('You clicked 0 times')

  wrapper.vm.increment()
  wrapper.vm.increment()

  expect(paragraph.text()).toBe('You clicked 2 times')
})
```

<Notes>
  aaaand this is how a component gets tested
</Notes>

---

thanks for coming to my Ted Talk.
 
---

```html
<template>
  <div>
    <p class="counter">You clicked {{ count }} times</p>
    <button @click="increment">increment</button>
  </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),

  methods: {
    increment() { this.count++ },
  },
}
</script>
```

---

```html
<template>
  <div>
    <p class="counter">You clicked {{ count }} times</p>
    <button @click="count++">increment</button>
  </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),
}
</script>
```

---

```html
<template>
  <div class="counter">
    <p>You clicked {{ count }} times</p>
    <button @click="count++">increment</button>         
  </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),
}
</script>
```

---

<span style={{ fontSize: '11rem' }}>‚ùå</span>

```py
Expected: "You clicked 0 times"
Received: "You clicked 0 timesincrement"
```

```py
TypeError: wrapper.vm.increment is not a function
```

---

<Image src="images/kalisi.jpg" size="cover" />

---

**False negative** error

<Notes>

Our test is broken. Our component is not.

</Notes>

---

This undermines our **confidence** in testing.

<Notes>
  ‚Äúomg tests fail at random times! üò≠‚Äù
</Notes>

---

## ‚ö†Ô∏è  Implementation Details  ‚ö†Ô∏è 

<Notes>
  What do I mean by implementation details?
</Notes>

---

# ü§¶‚Äç‚ôÄÔ∏è

Test does something **end users** or **other devs** won't.

<Notes>
  It becomes a third consumer. Needs to be taken into account.

  wrapper.vm.increment
</Notes>

---

# ü§¶‚Äç‚ôÄÔ∏è

Test breaks on **refactor**.

<Notes>
changing the internal structure without changing its observable behavior.
Martin Fowler.

  Changing class name.

  Let me introduce you...
</Notes>

---

`dom-testing-library`

<Appear>

<p>
‚ÄúThe more your tests resemble the way your software is used, the more confidence they can give you.‚Äù
<br />
<i>- Kent C. Dodds</i>
</p>

</Appear>

<Notes>
  Simple and complete testing utilities.

  IT IS NOT a test runner or framework.

  Works with any environment that provides DOM APIs, such as Jest or a real browser
</Notes>

---

`vue-testing-library`

`react-testing-library`

`svelte-testing-library`

`angular-testing-library`

...

<Notes>

Built on top of vue test utils. Hides methods that get you closer to testing
implementation details, while providing user-focused helpers.

If you want to avoid impl details, use tools that help you out.

</Notes>

---

```js
import { render, fireEvent } from 'vue-testing-library'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)                          

  

  

  
  

  
})
```

---

```js
import { render, fireEvent } from 'vue-testing-library'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)                          

  getByText(/you clicked 0 times/i)                              

  

  
  

  
})
```

---

```js
import { render, fireEvent } from 'vue-testing-library'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)                          

  getByText(/you clicked 0 times/i)                              

  const button = getByText(/increment/i)

  await fireEvent.click(button) 
  await fireEvent.click(button) 

  
})
```
---

```js
import { render, fireEvent } from 'vue-testing-library'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)                          

  getByText(/you clicked 0 times/i)                              

  const button = getByText(/increment/i)

  await fireEvent.click(button) 
  await fireEvent.click(button) 

  getByText(/you clicked 2 times/i)
})
```

---

```js
import { render, fireEvent } from 'vue-testing-library'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)

  getByText(/you clicked 0 times/i)      // query as a user would

  const button = getByText(/increment/i) // query as a user would

  await fireEvent.click(button)          // act as a user would
  await fireEvent.click(button)          // act as a user would

  getByText(/you clicked 2 times/i)      // query as a user would
})
```

---


```jsx
import { render, fireEvent } from 'react-testing-library'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(<Counter />)

  getByText(/you clicked 0 times/i)      // query as a user would

  const button = getByText(/increment/i) // query as a user would

  await fireEvent.click(button)          // act as a user would
  await fireEvent.click(button)          // act as a user would

  getByText(/you clicked 2 times/i)      // query as a user would
})
```

---

<span style={{ fontSize: '11rem' }}>‚úÖ</span>

---

(kinda) framework agnostic

# üëç

---

‚ÄúYeah well, whatever. It's a simple `Counter`.‚Äù

---

```html
<template>
  <div class="counter">
    <p>You clicked {{ count }} times</p>
    <button @click="increment">increment</button>
  </div>
</template>

<script>
import { mapActions, mapState } from 'vuex'

export default {
  computed: { ...mapState(['count']) },

  methods: { ...mapActions(['increment']) },
}
</script>
```

---

```js
const store = {
  state: {
    count: 0,
  },

  actions: {
    increment: ({ commit, state }) =>
      commit('SET_COUNT', state.count + 1),
  },

  mutations: {
    SET_COUNT: (state, count) => {
      state.count = count
    },
  },
}
```

---

```js
import { render, fireEvent } from 'vue-testing-library'
import Counter from './Counter.js'


test('increments value on click', async () => {
  const { getByText } = render(Counter)

  getByText(/you clicked 0 times/i)

  const button = getByText(/increment/i)

  await fireEvent.click(button)
  await fireEvent.click(button)

  getByText(/you clicked 2 times/i)
})
```

---

```js
import { render, fireEvent } from 'vue-testing-library'
import Counter from './Counter.js'
import store from './store.js'

test('increments value on click', async () => {
  const { getByText } = render(Counter, { store })

  getByText(/you clicked 0 times/i)

  const button = getByText(/increment/i)

  await fireEvent.click(button)
  await fireEvent.click(button)

  getByText(/you clicked 2 times/i)
})
```

---

Vuex is an **implementation detail**.

<Notes>
  I wouldn't suggest mocking store modules.
</Notes>

---

Let me show you something else.

<Notes>

Something that turned writing tests into a wonderful experience.

It's fun.

</Notes>

---

# Cypress üíö

<Notes>
  Is an amazing tool to write end-to-end tests. It can test anything that runs
  on a browser (including Vue).

  It comes fully packed with: mocking tools, assertions, helpers...

  Focused on DX. Meant to be used during the development cycle.
</Notes>

---

Let's see a day-to-day example...

<Notes>
  The kind of component we develop here at Holaluz daily.
</Notes>

---

a Todo app

# ü§∑‚Äç‚ôÄÔ∏è

---

`cypress-testing-library`

---

```js
it('adds 3 todos', () => {
  cy.visit('/')                                     

  
  
  
  
  




  
})
```

---

```js
it('adds 3 todos', () => {
  cy.visit('/')

  cy.getByLabelText(/what needs to be done/i)       
    
  




  
  
  
})
```

---

```js
it('adds 3 todos', () => {
  cy.visit('/')

  cy.getByLabelText(/what needs to be done/i)
    .type('follow @afontcu_ on Twitter{enter}')
    .type('learn testing with Cypress{enter}')
    .type('stop making demos with Todo apps{enter}')
  
  



  
})
```

---

```js
it('adds 3 todos', () => {
  cy.visit('/')

  cy.getByLabelText(/what needs to be done/i)
    .type('follow @afontcu_ on Twitter{enter}')
    .type('learn testing with Cypress{enter}')
    .type('stop making demos with Todo apps{enter}')

  cy.getByText('follow @afontcu_ on Twitter')
    .getByText('learn testing with Cypress')
    .getByText('stop making demos with Todo apps')
  cy.getByLabelText(/what needs to be done/i)
    .should('be.empty')
})
```

<Notes>
  Split in 3: Arrange, Act, Assert.
</Notes>

---

## A Cool Cypress Feature

XHR Stubbing

<Notes>
Stubbing responses enables you to control every aspect of the response, including the response body, the status, headers, and even network delay
</Notes>

---

```js
it('warns user on empty response', () => {     

  
  
  
  
   
 
 
 

 
 
})
```

---

```js
it('warns user on empty response', () => {
  cy.server()        // Hey Cypress,           
  
  
  
  
    
  
 
 
 
 
 
})
```

---

```js
it('warns user on empty response', () => {
  cy.server()        // Hey Cypress,
  cy.route({
    url: '/todos',   // on a /todos request...
    response: [],    // send back this response
  })
    
  
 
 
 

 
})
```

---

```js
it('warns user on empty response', () => {
  cy.server()        // Hey Cypress,
  cy.route({
    url: '/todos',   // on a /todos request...
    response: [],    // send back this response
  })
  .as('todos')
  
 
 
 

 
})
```

---

```js
it('warns user on empty response', () => {
  cy.server()        // Hey Cypress,
  cy.route({
    url: '/todos',   // on a /todos request...
    response: [],    // send back this response
  })
  .as('todos')
  
  cy.visit('/')
  
  

 
})
```

---

```js
it('warns user on empty response', () => {
  cy.server()        // Hey Cypress,
  cy.route({
    url: '/todos',   // on a /todos request...
    response: [],    // send back this response
  })
  .as('todos')
  
  cy.visit('/')
  
  cy.wait('@todos') // wait for the call

 
})
```

---

```js
it('warns user on empty response', () => {
  cy.server()        // Hey Cypress,
  cy.route({
    url: '/todos',   // on a /todos request...
    response: [],    // send back this response
  })
  .as('todos')
  
  cy.visit('/')
  
  cy.wait('@todos') // wait for the call

  cy.getByText('No TODOs found!')
})
```

---

```js
it('shows a loading state if API takes too long', () => {
  cy.server()
  cy.route({ url: '/todos', response: [], delay: 3000 })
    .as('todos')

  

  

  

  
    
})
```

---

```js
it('shows a loading state if API takes too long', () => {
  cy.server()
  cy.route({ url: '/todos', response: [], delay: 3000 })
    .as('todos')

  cy.visit('/')

  cy.getByText(/loading.../i)

  

  
  
})
```

---

```js
it('shows a loading state if API takes too long', () => {
  cy.server()
  cy.route({ url: '/todos', response: [], delay: 3000 })
    .as('todos')

  cy.visit('/')

  cy.getByText(/loading.../i)

  cy.wait('@todos')

  cy.queryByText(/loading.../i)
    .should('not.exist')
})
```

---

Hey, Adri.

Why would I write "component" tests...

...if I can use **Cypress**?

---

That's a pretty good question.

---

Component tests tend to be...

<Appear>

Cheaper

Faster

Focused on simpler problems

</Appear>

<Notes>
  Cheaper to write and run.

  Hit a smaller portion of your codebase.

  Better balance between cost, confidence and scope.

However, we are kinda getting there with tools such as Cypress.
</Notes>

---

## The key point

Always focus on the **confidence** they provide.

<Notes>

Finding a good balance between component-level tests and app-level tests.

</Notes>

---

## Wrapping up

<Appear>

Write tests, but **not too many**.

Use tools that resemble the way your software is **used**.

Use Cypress to cover **common happy paths**.

Add **component tests** to test critical parts and edge cases.

</Appear>

<Notes>
  1) Focus on ROI. Don't overthink things such as the testing pyramid.

  3) Cypress is also an amazing development tool.

  4) Component tests also to complex components.
</Notes>


---

## To learn more

<p style={{display: 'flex', fontSize: '1.2em', textAlign:'left'}}>
  <span style={{width: '550px', textAlign: 'right', marginRight: '1em'}}>Slides:</span>
  <span><a href="https://frontend-testing.now.sh">frontend-testing.now.sh</a></span>
</p>

<p style={{display: 'flex', fontSize: '1.2em', textAlign:'left'}}>
  <span style={{width: '550px', textAlign: 'right', marginRight: '1em'}}>Awesome Learning:</span>
  <span><a href="https://github.com/afontcu/awesome-learning#testing">github.com/afontcu/awesome-learning</a></span>
</p>

<p style={{display: 'flex', fontSize: '1.2em', textAlign:'left'}}>
  <span style={{width: '550px', textAlign: 'right', marginRight: '1em'}}>Cypress docs:</span>
  <span><a href="https://docs.cypress.io">docs.cypress.io</a></span>
</p>

<p style={{display: 'flex', fontSize: '1.2em', textAlign:'left'}}>
  <span style={{width: '550px', textAlign: 'right', marginRight: '1em'}}>Testing library docs:</span>
  <span><a href="http://testing-library.com">testing-library.com</a></span>
</p>

---

# That's all! <Waver />

`afontcu.dev` &nbsp;&nbsp;¬∑&nbsp;&nbsp; `@afontcu_` &nbsp;&nbsp;¬∑&nbsp;&nbsp; `npx afontcu`

<br /><br />

<Appear>

oh btw we're hiring! come test components with me:<br />
  <a href="http://holaluz.com/jobs">holaluz.com/jobs</a>

</Appear>
