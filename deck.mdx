import { Image, Notes, Appear } from '@mdx-deck/components'  
import future from '@mdx-deck/themes/future'
import aspect from '@mdx-deck/themes/aspect'

import customTheme from './theme'
import Waver from './Waver'
import Signature from './Signature'

export const themes = [future, aspect, customTheme]

<Notes>
For those of you who expected some exciting topic right after lunch...

well, I'm sorry.  
</Notes>

---

## The Pragmatic<br />Front-end Tester

<Signature />

<Notes>
This is about testing the front-end.

Feel free to leave.

However, if you choose to stay, I'll try to sell you the idea that (CHANGE SLIDE).
</Notes>

---

**Testing the front end** shouldn’t be that hard...

<Signature />

---

...and it isn’t _that_ hard.

<Notes>

Mindset, strategy and tools

</Notes>

<Signature />

---

## <Waver /> &nbsp; I’m Adrià Fontcuberta

<Appear>

Senior(?) Software Engineer @ **Holaluz**

Maintainer of **Testing Library**

Co-organizer of **VueJS BCN**

</Appear>

<p style={{fontSize: '0.8em', marginTop: '10rem'}}>
afontcu.dev &nbsp;&nbsp;·&nbsp;&nbsp; @afontq
</p>

---

Where is this coming from?

<Signature />

---

<Image
  src="/images/hard.jpg"
  size="cover"
  style={{ marginLeft: '-10vw' }}
/>

<Notes>
Tim
</Notes>

---

The Testing Pyramid™

<Signature />

<Notes>
  Mike Cohn, Succeeding with Agile. 2009
</Notes>

---

What were the **ideas** supporting the pyramid?

<Signature />

---

## Write tests

Make them fast and cheap.<br />Focus on value. Run them often.

<Appear>

Create shorter, faster **feedback loops**.

</Appear>

<Signature />

<Notes>
  "Cheap" to maintain.
</Notes>

---

Let’s keep things **pragmatic**.

<Signature />

<Notes>
Who has used Vue?
</Notes>

---

```html
<template>
  <div>
    <p class="counter">You clicked {{ count }} times</p>
    <button @click="increment">increment</button>
  </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),

  methods: {
    increment() { this.count++ },
  },
}
</script>
```

<Signature />

---

```
import { mount } from '@vue/test-utils'
import Counter from './Counter'

test('increments value on click', () => {
  const wrapper = mount(Counter)                      
  



  
  

  
})
```

<Notes>

Similar to Enzyme

</Notes>


<Signature />

---

```
import { mount } from '@vue/test-utils'
import Counter from './Counter'

test('increments value on click', () => {
  const wrapper = mount(Counter)

  const paragraph = wrapper.find('.counter')
  expect(paragraph.text()).toBe('You clicked 0 times')

  
  

  
})
```

<Signature />

---

```
import { mount } from '@vue/test-utils'
import Counter from './Counter'

test('increments value on click', () => {
  const wrapper = mount(Counter)

  const paragraph = wrapper.find('.counter')
  expect(paragraph.text()).toBe('You clicked 0 times')

  wrapper.vm.increment()
  wrapper.vm.increment()

  expect(paragraph.text()).toBe('You clicked 2 times')
})
```

<Notes>
  aaaand this is how a component gets tested
</Notes>

<Signature />

---

Thanks for coming to my TED Talk.

<Signature />

---

```html
<template>
  <div>
    <p class="counter">You clicked {{ count }} times</p>   
    <button @click="increment">increment</button>
  </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),

  methods: {
    increment() { this.count++ },
  },
}
</script>
```

<Signature />

---

```html
<template>
  <div>
    <p class="counter">You clicked {{ count }} times</p>   
    <button @click="add">increment</button>
  </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),

  methods: {
    add() { this.count++ },
  },
}
</script>
```

<Signature />

---

<span style={{ fontSize: '5rem' }}>❌</span>

```css
wrapper.vm.increment is not a function
```


<Signature />

---

# False positive error

<Appear>

“tests fail at random times”<br /><br />(╯°□°)╯︵ ┻━┻ 

</Appear>

<Notes>

Our test is broken. Our component is not.

This undermines our confidence in testing.

</Notes>

<Signature />

---

What went wrong?

<Signature />

---

Our test became a different **consumer**.

<Notes>
  Needs to be taken into account. Fulfill its requirements.
</Notes>

<Signature />

---

a... what?

<Signature />

<Notes>
  To answer this question we need to take a step back.
</Notes>

---

## What is a test?

<Appear>

input ➡ **Function** ➡ output

</Appear>

<Signature />

---

## What is a test?

input ➡ **Component** ➡ output

<Signature />

---

What are our **inputs** and **outputs**?

<Notes>
  Put it another way: who's emiting and receiving those inputs and outputs?
</Notes>

<Signature />

---

### Your code has two users

<Appear>

👥 &nbsp;The end user

👩‍💻 &nbsp;The developer

</Appear>

<Notes>
   You are your own code’s consumer. Let it sink.
</Notes>

<Signature />

---

## Inputs

<Appear>

👩‍💻&nbsp; Props + Data streams

👥&nbsp; Interactions

</Appear>

<Notes>
  Data fetching on mount, subscriptions...

  Clicking, typing
</Notes>

<Signature />

---

## Outputs

<Appear>

👩‍💻 &nbsp;Side Effects

👥&nbsp; DOM elements

</Appear>

<Notes>
  HTTP requests, Cookies, `console.log()`, `this.$emit()`

  input, div, whatever. Elements on the screen
</Notes>

<Signature />

---

99% of times, that’s everything you want to focus on.

<Signature />

---

In:

### Props, Data Streams + Interactions

<br />

Out:

### Side effects + DOM nodes

<Signature />

---

```js
wrapper.vm.increment()
```

```js
wrapper.find('.counter')
```

<span style={{fontSize:'4.5rem',marginTop: '4rem',display:'block'}}>
  👥? 👩‍💻?
</span>

<Signature />

---

## Achievement unlocked!

You earned yourself a third user&nbsp; 🤦‍♀️

<br /><br />

<Appear>

The Test 🔎

</Appear>

<Notes>
  If a test relies on implementation details, then the test becomes a third 
  user. And you’re gonna need to please it.
</Notes>

<Signature />

---

The test became a different **consumer**.

<span style={{textAlign:'left',fontSize:'5rem', display: 'block'}}>
  👥&nbsp;&nbsp;👩‍💻&nbsp;&nbsp;🔎
</span>

<Notes>
  How can we write resilient tests that do not depend on impl details and keep
  us away from unlocking a third user?
</Notes>

<Signature />

---

## okay, so...

<Appear>

How can I stay away from implementation details?

</Appear>

<Signature />

---

## DOM Testing Library

<br />

<Appear>

<p>
“The more your tests resemble the way your software is used, the more <strong>confidence</strong> they can give you.”
<br />
<br />
<small><i>- Kent C. Dodds</i></small>
</p>

</Appear>

<Notes>
  Simple and complete testing utilities.

  IT IS NOT a test runner or framework.
</Notes>

<Signature />

---

<div style={{textAlign:'left'}}>

**React** Testing Library

**Vue** Testing Library

**Svelte** Testing Library

**Angular** Testing Library

**Cypress** Testing Library

</div>

...

<Notes>

If you want to avoid impl details, use tools that help you out.

</Notes>

<Signature />

---

```js
import { render, fireEvent } from '@testing-library/vue'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)                    

  

  

  
  

  
})
```

<Signature />

---

```js
import { render, fireEvent } from '@testing-library/vue'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)                    

  expect(getByText(/you clicked 0 times/i)).toBeTruthy()

  

  
  

  
})
```

<Signature />

---

```js
import { render, fireEvent } from '@testing-library/vue'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)                    

  expect(getByText(/you clicked 0 times/i)).toBeTruthy()

  const button = getByText(/increment/i)




  
})
```

<Signature />

---

```js
import { render, fireEvent } from '@testing-library/vue'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)                    

  expect(getByText(/you clicked 0 times/i)).toBeTruthy()

  const button = getByText(/increment/i)

  await fireEvent.click(button) 
  await fireEvent.click(button) 

  
})
```
<Signature />

---

```js
import { render, fireEvent } from '@testing-library/vue'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)                    

  expect(getByText(/you clicked 0 times/i)).toBeTruthy()

  const button = getByText(/increment/i)

  await fireEvent.click(button) 
  await fireEvent.click(button) 

  expect(getByText(/you clicked 2 times/i)).toBeTruthy()
})
```

<Notes>

Query as a user would.

Act as a user would.

</Notes>

<Signature />

---


```jsx
import { render, fireEvent } from '@testing-library/react'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(<Counter />)                

  expect(getByText(/you clicked 0 times/i)).toBeTruthy() 

  const button = getByText(/increment/i)

  await fireEvent.click(button) 
  await fireEvent.click(button) 

  expect(getByText(/you clicked 2 times/i)).toBeTruthy() 
})
```

<Signature />

---

## We wrote a test that...

<Appear>

...is _kinda_ framework agnostic.

...stays closer to our users.

</Appear>

<Signature />

---

But wait, there’s more!

<Signature />

---

```html
<label for="username">An amazing label</label>
<input id="username" type="text">
```

```js
const input = getByLabelText('An amazing label')
```

<Signature />

---

## Wrapping it up

<Appear>

Write tests, but **not too many**. Focus on value.

Inputs & outputs: Components are just **functions**!

Use tools that resemble the way your software is **used**.

</Appear>

<Notes>
Focus on ROI. Don't overthink things such as the testing pyramid.

Think in terms of inputs and outputs.

Avoid the test user.

</Notes>


<Signature />

---

# Start now!

testing-library.com

<Signature />

---

# That’s all! <Waver />

@afontq

afontcu.dev

<Notes>
That's everything I got time to tell you about today.

Thank you very much for having me here, it's been truly and honor.

Enjoy the rest of the conference!

</Notes>
