import { Image, Notes, Appear, Embed } from '@mdx-deck/components'  
import { FullScreenCode, Invert } from 'mdx-deck/layouts'
import future from '@mdx-deck/themes/future'
import aspect from '@mdx-deck/themes/aspect'
import highlight from '@mdx-deck/themes/syntax-highlighter-prism'

import customTheme from './theme'

import Waver from './Waver'

export const themes = [future, aspect, highlight, customTheme]

## The Pragmatic Front-end Tester

---

I wanted to talk about **testing the front-end**.

<Notes>
  "Who's writing FE apps? Who's testing? Are you confiden? Would you ship
  without manually testing?"

Over the years, FE apps have increased in complexity, responsibility has moved 
from the backend to the FE. 
</Notes>

---

...and I wanted to do it following a **pragmatic** approach.

---

## Some Facts

<Appear>

I have ~30 minutes üèÉ‚Äç‚ôÇÔ∏è

<s>Why should we test?</s>

<s>Testing beyond avoiding regressions</s>

<s>Visual regression testing</s>

Focused on front-end apps

</Appear>

<Notes>
  Focus on avoiding regressions, not discovering best ways of developing a feature

  Frontend apps: Ni Node ni librerias ni otros contextos
</Notes>

---

## üëã Hi! I'm Adri√† Fontcuberta

Senior(?) Front-end Engineer @ **Holaluz**

`afontcu.dev` &nbsp;&nbsp;¬∑&nbsp;&nbsp; `@afontcu_` &nbsp;&nbsp;¬∑&nbsp;&nbsp; `npx afontcu`

---

<Invert>

<Image src="images/drake-1.jpg" size="contain" />

</Invert>

---

<Invert>

<Image src="images/drake-2.jpg" size="contain" />

</Invert>

---

So...

I'm sorry I'm gonna use a Counter component

# ü§∑‚Äç‚ôÄÔ∏è

---

```html
<template>
      <div>
    <p class="count">You clicked {{ count }} times</p>
    <button @click="increment">increment</button>
      </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),

  methods: {
    increment() { this.count++ },
  },
}
</script>
```

---

```
import { mount } from '@vue/test-utils'
import Counter from './Counter'

test('increments value on click', () => {
  const wrapper = mount(Counter)
  const paragraph = wrapper.find('.count')

  expect(paragraph.text()).toBe('You clicked 0 times')

  wrapper.vm.increment()
  wrapper.vm.increment()

  expect(paragraph.text()).toBe('You clicked 2 times')
})
```

---

thanks for coming to my Ted Talk.
 
---

```html
<template>
      <div>
    <p class="count">You clicked {{ count }} times</p>
    <button @click="increment">increment</button>
      </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),

  methods: {
    increment() { this.count++ },
  },
}
</script>
```

---

```html
<template>
      <div>
    <p class="count">You clicked {{ count }} times</p>
    <button @click="count++">increment</button>
      </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),
}
</script>
```

---

```html
<template>
      <div>
    <p class="counter">You clicked {{ count }} times</p>
    <button @click="count++">increment</button>
      </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),
}
</script>
```

---

<span style={{ fontSize: '11rem' }}>‚ùå</span>

```py
find() did not return .counter, cannot call text() on empty Wrapper
```

```py
TypeError: wrapper.vm.increment is not a function
```

---

<Image src="images/kalisi.jpg" size="cover" />

---

**False negative** error.

<Appear>

Our test is broken. Our component is not.

</Appear>

---

This undermines our **confidence** in testing.

‚Äúomg tests fail at random times! üò≠‚Äù

---

# ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏èÔ∏èÔ∏èÔ∏èÔ∏èÔ∏è 

Smells like **Implementation Details**

---

### Implementation detail #1

<Appear>

Test does something with your code its **consumers** won't.

1) End users

2) Other devs

3) Tests ‚ùå

</Appear>

<Notes>
  If test is doing something different from user & developer, it becomes a third
  consumer.
  User: input interactions, output side effects
  Dev: input props, output elements, event

  wrapper.vm.increment
</Notes>

---

### Implementation detail #2

<Appear>

Your test breaks on **refactor**.

‚Äúchanging the internal structure without changing its observable behavior.‚Äù

</Appear>

<Notes>
  Martin Fowler.

  Changing class name.
</Notes>

---

`dom-testing-library`

<Appear>

> ‚ÄúThe more your tests resemble the way your software is used, the more confidence they can give you.‚Äù - _Kent C. Dodds_

</Appear>

<Notes>
  Simple and complete testing utilities.

  IT IS NOT a test runner or framework.

  Works with any environment that provides DOM APIs, such as Jest, Mocha + JSDOM, or a real browser
</Notes>

---

`vue-testing-library`

`react-testing-library`

`svelte-testing-library`

`angular-testing-library`

...

<Notes>

Built on top of vue test utils. Hides methods that get you closer to testing
implementation details, while providing user-focused helpers.

If you want to avoid impl details, use tools that help you out.

Helps you querying for nodes similarly to how users would find them.

</Notes>

---

```js
import { render, fireEvent } from 'vue-testing-library'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)

  getByText(/you clicked 0 times/i)                              

  const button = getByText(/increment/i)

  await fireEvent.click(button) 
  await fireEvent.click(button) 

  getByText(/you clicked 2 times/i)
})
```

---

```js
import { render, fireEvent } from 'vue-testing-library'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)

  getByText(/you clicked 0 times/i)      // query as a user would

  const button = getByText(/increment/i) // query as a user would

  await fireEvent.click(button)          // act as a user would
  await fireEvent.click(button)          // act as a user would

  getByText(/you clicked 2 times/i)      // query as a user would
})
```

---


```jsx
import { render, fireEvent } from 'react-testing-library'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(<Counter />)

  getByText(/you clicked 0 times/i)      // query as a user would

  const button = getByText(/increment/i) // query as a user would

  await fireEvent.click(button)          // act as a user would
  await fireEvent.click(button)          // act as a user would

  getByText(/you clicked 2 times/i)      // query as a user would
})
```

---

<span style={{ fontSize: '11rem' }}>‚úÖ</span>

---

(kinda) framework agnostic

# üëç

---

Yeah well, sure. It's a simple `Counter`, so whatever.

---

```jsx
import { mapActions, mapState } from 'vuex'

const Counter = {
  render() {
    return (
      <div>
        <p class="count">You clicked {this.count} times</p>
        <button onClick={this.increment}>increment</button>
      </div>
    )
  },

  computed: { ...mapState(['count']) },

  methods: { ...mapActions(['increment']) },
}
```

---

```js
const store = {
  state: {
    count: 0,
  },

  actions: {
    increment: ({ commit, state }) =>
      commit('SET_COUNT', state.count + 1),
  },

  mutations: {
    SET_COUNT: (state, count) => {
      state.count = count
    },
  },
}
```

---

```js
import { render, fireEvent } from 'vue-testing-library'
import CounterStore from './CounterStore.js'
import store from './store.js'

test('increments value on click', async () => {
  const { getByText } = render(CounterStore, { store })

  getByText(/you clicked 0 times/i)

  const button = getByText(/increment/i)

  await fireEvent.click(button)
  await fireEvent.click(button)

  getByText(/you clicked 2 times/i)
})
```

---

Vuex is an **implementation detail**.

<Notes>
  I wouldn't suggest mocking store modules.
</Notes>

---

Let me show you something else.

---

Something that turned writing tests...

...into a **wonderful experience**.

---

# Cypress üíö

<Appear>

(and `cypress-testing-library`)

</Appear>

<Notes>
  Is an amazing tool to write end-to-end tests. It can test anything that runs
  on a browser (including Vue).

  It includes a ton of tools and features out-of-the-box: mocking/stubbing,
  assertions, DOM selectors...

  Focus on DX. Meant to be used during the development cycle.
</Notes>

---

So...

I'm sorry I'm gonna use a Todo app

# ü§∑‚Äç‚ôÄÔ∏è

---

```js
it('adds 3 todos', () => {
  cy.visit('/')

  cy.getByLabelText(/what needs to be done?/i)
    .type('follow @afontcu_ on Twitter{enter}')
    .type('learn testing with Cypress{enter}')
    .type('stop making demos with Todo apps{enter}')
  
  cy.getAllByTestId('todolist-item')
    .should('have.length', 3)
})
```

---


```html
<div v-for="todo in todos" :key="todo.id">
  <label data-testid="todolist-item">
    {{ todo.title }}
  </label>
</div>
```

---


```js
it('adds 3 todos', () => {
  cy.visit('/')

  cy.getByLabelText(/what needs to be done?/i)
    .type('follow @afontcu_ on Twitter{enter}')
    .type('learn testing with Cypress{enter}')
    .type('stop making demos with Todo apps{enter}')
  
  cy.getAllByTestId('todolist-item')
    .should('have.length', 3)
})
```

---

## Cool Cypress feature #1

XHR Stubbing

<Notes>
Stubbing responses enables you to control every aspect of the response, including the response body, the status, headers, and even network delay
</Notes>

---

```js
it('starts with zero items', () => {
  cy.server()
  cy.route({ url: '/todos', response: [] })
    .as('todos')
  
  cy.visit('/')
  
  cy.wait('@todos')
    .its('response.body')
    .should('have.length', 0)
  
  cy.getAllByTestId('todolist-item')
    .should('have.length', 0)
})
```

---

```js
it('shows a loading state if API request takes too long', () => {
  cy.server()
  cy.route({ url: '/todos', response: [], delay: 3000 })
    .as('todos')

  cy.visit('/')

  cy.getByText(/loading.../i)

  cy.wait('@todos') // wait for the network call to complete

  cy.queryByText(/loading.../i).should('not.exist')
})
```

---

## Cool Cypress feature #2

Custom Commands

---

```js
// /support/commands.js
Cypress.Commands.add('addTodo', todo => {
  cy.getByLabelText(/what needs to be done?/i, { log: false })
    .type(todo, { log: false })
    .type('{enter}', { log: false })
  
  cy.log('Inserted todo', todo)
})

// later in your tests...
cy.addTodo('Improve tests by using Custom Commands')
```

---

Hey, Adri.

Why would I write "component" tests...

...if I can use **Cypress**?

---

That's a pretty good question.

---

<p style={{textAlign:'left'}}>Component tests tend to **be cheaper**.</p>

<p style={{textAlign:'left'}}>Component tests tend to **be faster**.</p>

<p style={{textAlign:'left'}}>Component tests tend to **narrower**.</p>

<p style={{textAlign:'left'}}>Component tests tend to **focus on simpler problems**.</p>

<Notes>
  Cheaper to write and run.

  Hit a smaller portion of your codebase.

  Better balance between cost, confidence and scope.

However, we are kinda getting there with tools such as Cypress.
</Notes>

---

## The key

Finding a good balance between **component-level** tests and **app-level** tests.

<Appear>

Always focus on the **confidence** they provide.

</Appear>

---

## Wrapping up

<Appear>

Write tests, but **not too many**.

Use tools that resemble the way your software is **used**.

Use Cypress to cover **common happy paths** and as development tool.

Add **component tests** to test critical parts and edge cases.

</Appear>


---

## To learn more

[frontend-testing.now.sh](https://frontend-testing.now.sh)

[github.com/afontcu/awesome-learning#testing](https://github.com/afontcu/awesome-learning#testing)

[docs.cypress.io](https://docs.cypress.io)

[testing-library.com](http://testing-library.com)

---

# That's all! <Waver />

`afontcu.dev` &nbsp;&nbsp;¬∑&nbsp;&nbsp; `@afontcu_` &nbsp;&nbsp;¬∑&nbsp;&nbsp; `npx afontcu`

<br /><br />

<Appear>

<small>
  oh btw we r hiring! k thx bye: <a href="http://holaluz.com/jobs">holaluz.com/jobs</a>
</small>

</Appear>
