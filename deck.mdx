import { Image, Notes, Appear, Embed } from '@mdx-deck/components'  
import { FullScreenCode, Invert, Split } from 'mdx-deck/layouts'
import future from '@mdx-deck/themes/future'
import aspect from '@mdx-deck/themes/aspect'

import customTheme from './theme'
import Waver from './Waver'

export const themes = [future, aspect, customTheme]

## The Pragmatic Front-end Tester

---

**Testing the front end** shouldn't be that hard...

---

...and it isn't _that_ hard

<Notes>

Mindset, strategy and tools

</Notes>

---

## Some facts

<Appear>

<s>Why should we test?</s>

<s>Testing as a design tool</s>

<s>Visual regression testing</s>

This is my experience, so YMMV.

I work on front-end applications.

</Appear>

<Notes>
  Speed things up.

  Testing as a code design tool.

  Frontend apps: Ni Node ni librerias ni otros contexto
</Notes>

---

## <Waver /> Hi!

I'm Adrià Fontcuberta

<Appear>

Senior(?) Software Engineer @ **Holaluz**

Maintainer of **Testing Library**

<small>afontcu.dev &nbsp;&nbsp;·&nbsp;&nbsp; @afontcu_ &nbsp;&nbsp;·&nbsp;&nbsp; npx afontcu</small>

</Appear>

<Notes>
Testing Library: un proyecto open source que ofrece varias opciones
para testear los principales frameworks front-end del momento.
</Notes>

---

The Testing Pyramid™

---

<Image src="images/drake-nah.png" size="contain" />

---

Let's keep things **pragmatic**, shall we?

---

<Image src="images/drake-yea.jpg" size="contain" />

---

Let's see a day-to-day example...

<Notes>
  The kind of component we develop here at Holaluz daily.
</Notes>

---

a Counter component

# 🤷‍♀️

---

```html
<template>
  <div>
    <p class="counter">You clicked {{ count }} times</p>
    <button @click="increment">increment</button>
  </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),

  methods: {
    increment() { this.count++ },
  },
}
</script>
```

---

```
import { mount } from '@vue/test-utils'
import Counter from './Counter'

test('increments value on click', () => {
  const wrapper = mount(Counter)                      
  



  
  

  
})
```

<Notes>

Similar a Enzyme

</Notes>


---

```
import { mount } from '@vue/test-utils'
import Counter from './Counter'

test('increments value on click', () => {
  const wrapper = mount(Counter)
  const paragraph = wrapper.find('.counter')

  expect(paragraph.text()).toBe('You clicked 0 times')

  
  

  
})
```

---

```
import { mount } from '@vue/test-utils'
import Counter from './Counter'

test('increments value on click', () => {
  const wrapper = mount(Counter)
  const paragraph = wrapper.find('.counter')

  expect(paragraph.text()).toBe('You clicked 0 times')

  wrapper.vm.increment()
  wrapper.vm.increment()

  expect(paragraph.text()).toBe('You clicked 2 times')
})
```

<Notes>
  aaaand this is how a component gets tested
</Notes>

---

thanks for coming to my Ted Talk.

---

is it wrong?

---

nah.

---

can we do better?

---

think so.
 
---

```html
<template>
  <div>
    <p class="counter">You clicked {{ count }} times</p>
    <button @click="increment">increment</button>
  </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),

  methods: {
    increment() { this.count++ },
  },
}
</script>
```

---

```html
<template>
  <div>
    <p class="counter">You clicked {{ count }} times</p>
    <button @click="count++">increment</button>
  </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),

  // methods: {
  //   increment() { this.count++ },
  // },
}
</script>
```

---

```html
<template>
  <div class="counter">
    <p>You clicked {{ count }} times</p>
    <button @click="count++">increment</button>         
  </div>
</template>

<script>
export default {
  data: () => ({ count: 0 }),

  // methods: {
  //   increment() { this.count++ },
  // },
}
</script>
```

---


<span style={{ fontSize: '5rem' }}>❌</span>

```py
Expected: "You clicked 0 times"
Received: "You clicked 0 timesincrement"
```
<br />
<br />
<span style={{ fontSize: '5rem' }}>❌</span>

```css
TypeError:
wrapper.vm.increment is not a function
```


---

**False positive** error

<Notes>

Our test is broken. Our component is not.

This undermines our confidence in testing.

</Notes>

---

“tests fail at random times 😭 pls send help”

---

## ⚠️  Implementation Details  ⚠️ 

<Notes>
  What do I mean by implementation details?
</Notes>

---

# Smell #1

Test breaks on a **refactor**.

<Notes>

changing the internal structure without changing its observable behavior.
Martin Fowler.

if the external behavior does not change, why would a test fail?

exemple: Changing class name.

</Notes>

---

# Smell #2

Test becomes a different **consumer**.

<Notes>
  It becomes a third consumer. Needs to be taken into account.

  wrapper.vm.increment
</Notes>

---

a... what?

---

Your code has two users:

<Appear>

The end user 👥

The developer 👩‍💻

</Appear>

<Notes>
   You are your own code’s consumer. Let it sink.

   Nuestro código tiene que responder a les necesidades de ambos usuarios.
</Notes>

---

input ➡ Function ➡ output

---

input ➡ Component ➡ output

---

<Appear>

**Inputs**: Props and interactions.

**Outputs**: Side Effects and DOM elements.

</Appear>


<Notes>
  Clicking, typing
  Props

  HTTP requests, Cookies, `console.log()`, `this.$emit()`
  an input, a div, whatever. Elements on the screen
</Notes>

---

99% of times, that’s everything you want to focus on.

---

```js
test('increments value on click', () => {
  const paragraph = wrapper.find('.counter')

  //...

  wrapper.vm.increment()
  wrapper.vm.increment()

  // ...
})
```

👥? 👩‍💻?

---

Achievement unlocked! 🚀 

You earned yourself a third user. 🤦‍♀️

<br /><br />
<Appear>

The Test™ 🔎

</Appear>

<Notes>
  If a test relies on implementation details, then the test becomes a third 
  user. And you’re gonna need to please it.

  How can we write resilient tests that do not depend on impl details and keep
  us away from unlocking a third user?
</Notes>

---

## DOM Testing Library

<br />

<Appear>

<p>
“The more your tests resemble <b>the way your software is used</b>, the more confidence they can give you.”
<br />
<br />
<small><i>- Kent C. Dodds</i></small>
</p>

</Appear>

<Notes>
  Simple and complete testing utilities.

  IT IS NOT a test runner or framework.

  Works with any environment that provides DOM APIs, such as Jest or a real browser
</Notes>

---

<div style={{textAlign:'left'}}>

**React** Testing Library

**Vue** Testing Library

**Svelte** Testing Library

**Angular** Testing Library

</div>

...

<Notes>

Built on top of vue test utils. Hides methods that get you closer to testing
implementation details, while providing user-focused helpers.

If you want to avoid impl details, use tools that help you out.

</Notes>

---

```js
import { render, fireEvent } from '@testing-library/vue'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)                          

  

  

  
  

  
})
```

---

```js
import { render, fireEvent } from '@testing-library/vue'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)                          

  expect(getByText(/you clicked 0 times/i)).toBeTruthy()     

  

  
  

  
})
```

---

```js
import { render, fireEvent } from '@testing-library/vue'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)                          

  expect(getByText(/you clicked 0 times/i)).toBeTruthy()     

  const button = getByText(/increment/i)




  
})
```

---

```js
import { render, fireEvent } from '@testing-library/vue'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)                          

  expect(getByText(/you clicked 0 times/i)).toBeTruthy()     

  const button = getByText(/increment/i)

  await fireEvent.click(button) 
  await fireEvent.click(button) 

  
})
```
---

```js
import { render, fireEvent } from '@testing-library/vue'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(Counter)                          

  expect(getByText(/you clicked 0 times/i)).toBeTruthy()     

  const button = getByText(/increment/i)

  await fireEvent.click(button) 
  await fireEvent.click(button) 

  expect(getByText(/you clicked 2 times/i)).toBeTruthy()     
})
```

<Notes>

Query as a user would.

Act as a user would.

</Notes>

---


```jsx
import { render, fireEvent } from '@testing-library/react'
import Counter from './Counter'

test('increments value on click', async () => {
  const { getByText } = render(<Counter />)                      

  expect(getByText(/you clicked 0 times/i)).toBeTruthy() 

  const button = getByText(/increment/i)

  await fireEvent.click(button) 
  await fireEvent.click(button) 

  expect(getByText(/you clicked 2 times/i)).toBeTruthy() 
})
```

---

<span style={{ fontSize: '11rem' }}>✅</span>

---

_Kinda_ framework agnostic.

Closer to our users.

Farther from implementation details.

---

“Yeah well, whatever. It's a simple `Counter`.”

---

```html
<template>
  <div class="counter">
    <p>You clicked {{ count }} times</p>
    <button @click="increment">increment</button>
  </div>
</template>

<script>
import { mapActions, mapState } from 'vuex'

export default {
  computed: { ...mapState(['count']) },

  methods: { ...mapActions(['increment']) },
}
</script>
```

---

```js
export const store = {
  state: {
    count: 0,
  },

  actions: {
    increment: ({ commit, state }) =>
      commit('SET_COUNT', state.count + 1),
  },

  mutations: {
    SET_COUNT: (state, count) => {
      state.count = count
    },
  },
}
```

---

```js
import { render, fireEvent } from '@testing-library/vue'
import Counter from './Counter.js'


test('increments value on click', async () => {
  const { getByText } = render(Counter)

  getByText(/you clicked 0 times/i)

  const button = getByText(/increment/i)

  await fireEvent.click(button)
  await fireEvent.click(button)

  getByText(/you clicked 2 times/i)
})
```

---

```js
import { render, fireEvent } from '@testing-library/vue'
import Counter from './Counter.js'
import store from './store.js'

test('increments value on click', async () => {
  const { getByText } = render(Counter, { store })

  getByText(/you clicked 0 times/i)

  const button = getByText(/increment/i)

  await fireEvent.click(button)
  await fireEvent.click(button)

  getByText(/you clicked 2 times/i)
})
```

---

Vuex is an **implementation detail**.

<Notes>
  I wouldn't suggest mocking store modules.
</Notes>

---

"Hm, that's an integration test because potatoes"

"Well, actually, you are writing unit tests, then"

<Notes>
  Feedback loops as short as possible.

  (again, focused on regression, not code design)
</Notes>

---

<p>
“A unit is whatever a unit test can test easily.”
<br />
<br />
<small><i>- Michael Feathers</i></small>
</p>

---

## A word of caution

---

“Testing is hard”

<Notes>
hard to test --> doing too much and too coupled

doing too much --> hard to understand

hard to understand --> hard to maintain

hard to maintain --> one could argue that unmaintainable code is not good code.

we blame the test instead of blaming poorly designed code.

</Notes>

---

Front-end development is still **software development** (wait what).

<Appear>

Bear software principles in mind.

</Appear>

<Notes>
  Coupling. Decouple from framework?

  Think of testing not only as a regression testing tool, but as a way to
  achieve a better design for your code.
</Notes>

---

## Wrapping up

<Appear>

Write tests, but **not too many**.

Use tools that resemble the way your software is **used**.

Testing is hard? **Blame the code**.

</Appear>

<Notes>
  Focus on ROI. Don't overthink things such as the testing pyramid.

  Avoid the test user.

  Component tests also to complex components.
</Notes>


---

## To learn more


  <a href="https://github.com/afontcu/awesome-learning#testing">www.github.com/afontcu/awesome-learning</a>

  <a href="http://testing-library.com">www.testing-library.com</a>

---

# That's all! <Waver />

afontcu.dev &nbsp;&nbsp;·&nbsp;&nbsp; @afontcu_ &nbsp;&nbsp;·&nbsp;&nbsp; npx afontcu

<small>
(I have stickers!)
</small>
